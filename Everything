Exc 1
Questions: 
Is the dictionary in alphabetical order?
Thoughts on the problem: 
Obvious but slow solution is to go through all the words in the given dictionary that are "smaller" than my word. 
To fasten this up, I  can use a binary search. I can't use classic binary search since I don't know the length of the dictionary. 
Instead of this, I will use a modified version which goes from the start, always jumping forward by an increasing power of two.
Whenever I reach the end of the dictionary, or a "bigger" word than my one, I will go backward by half of the last jump and do the classic binary search from there. 
Questions for myself: What if the word isn't in the dictionary? How can I set the upperBound? (in the first part, when going up)
Test cases:
Case one:
TrivialDictionary = {"", "boo", "foo", "moo", "zoo"};
isInDictionary("canary") = false;
isInDictionary("foo") = true;
isInDictionary("") = true;
Case two:
TrivialDictionary = {"boo", "foo", "moo", "zoo"};
isInDictionary("") = false;
isInDictionary("zoo") = true;
isInDictionary("boo") = true;

Code:

isInDictionary(string word){
int upperBound = -1, lowerBound = 1, currentPlace = 0;
  while(upperBound-lowerBound != 1){
    if(word == TrivialDictionary.wordAt(upperBound)){
      return true;
    }
    //if my word is bigger than the dictionary one, go ahead
    if(word>TrivialDictionary.wordAt(currentPlace*2)){
      lowerBound*=2;
    }
    //if my word is smaller, or I hit the end, go back
    if(word<TrivialDictionary.wordAt(currentPlace*2)){
      upperBound =/2;
    }
  }
  return false;
}


Exc 2
Questions: 
Thoughts on the problem:
If I sort the numbers and I will take a look at median (or the bigger median in case of even number if values), 
it will be a number representing majority - if the majority exists. 
Then I could count how many times is that number present in my collection and wheter it is more than 50%. 
This will take O (n log n) for n numbers, because of the sort. 
Another approach is to make a structure to keep track of how many times I have seen each number, then look if the highest value is high enough. 
This will take O (n).
I will use the first method since it's simpler to code. 
Questions for myself:
Will the second approach really take O(n)? What about memory? Can I use hash table?
Test cases:
testOne = {1, 14, 5, 5}
hasMajority(testOne) = null
testTwo = {1, 5, 14, 5, 5}
hasMajority(testTwo) = 5
testThree = {6, 6, 4, 6, 6, 7}
hasMajority(testThree) = 6
testFour = {}
hasMajority = null
Code:
hasMajority(ArrayList testCase){
  testCase.sort();
  int median = testCase.get((testCase.length()+1)/2);//if this doesn't work, split it into cases
  int numberOfMedians = 0;
  for(int i = 0; i<testCase.length(); i++){
    if(testCase.get(i)==median){
      numberOfMedians++;
    }
  }
  if(numberOfMedians>testCase.length()/2){
    reutrn median;
  } else {
    return null;
  }
}
Exc 3
Questions:
We can have several identical values in the array, for example {3, 4, 4, 5}. If that's the case, nthLargest(3) would 
return 4 or 3? Would nthLargest(2) return the same value as nthLargest(3)? Can we have identical return values for 
different inputs? I will work with that case. 
Thoughts on the problem:
We can sort it. O(s log s) where s is the size of array
We can go through the array n-times to find out which is the n-th largest. O(n*s) or O(s^2) in the worst case. 
We can have an array with n largest elements. I don't know how I can update it though. 

TestCases:
testOne = {7, 4, 6, 1}
nthLargest = {4}

Code:
class largest{
List <Integer> integers;
  largest (List<Integer> input){
    integers = input;
  }
  nthLargest(int n){
    integers.sort;
    integers.reversel
    return integers.get(n);
  }
}

