Exc 1
Questions: 
Is the dictionary in alphabetical order?
Thoughts on the problem: 
Obvious but slow solution is to go through all the words in the given dictionary that are "smaller" than my word. 
To fasten this up, I  can use a binary search. I can't use classic binary search since I don't know the length of the dictionary. 
Instead of this, I will use a modified version which goes from the start, always jumping forward by an increasing power of two.
Whenever I reach the end of the dictionary, or a "bigger" word than my one, I will go backward by half of the last jump and do the classic binary search from there. 
Questions for myself: What if the word isn't in the dictionary? How can I set the upperBound? (in the first part, when going up)
Test cases:
Case one:
TrivialDictionary = {"", "boo", "foo", "moo", "zoo"};
isInDictionary("canary") = false;
isInDictionary("foo") = true;
isInDictionary("") = true;
Case two:
TrivialDictionary = {"boo", "foo", "moo", "zoo"};
isInDictionary("") = false;
isInDictionary("zoo") = true;
isInDictionary("boo") = true;

Code:

isInDictionary(string word){
int upperBound = 2, lowerBound = 0;
  while(upperBound-lowerBound != 1){
    if(word == TrivialDictionary.wordAt(upperBound)){
      return true;
    }
    //if my word is bigger than the dictionary one, go ahead
    if(word>TrivialDictionary.wordAt(upperBound)){
      upperBound*=2;
    }
    //if my word is smaller, or I hit the end, go back
    if(){
      
    }
  }
  return false;
}


Exc 2
Questions: 
Thoughts on the problem:
If I sort the numbers and I will take a look at median, it will be a number representing majority - if the majority exists. 
Then I could count how many times is that number present in my collection and wheter it is more than 50%. 
This will take O (n log n) for n numbers, because of the sort. 
Another approach is to make a structure to keep track of how many times I have seen each number, then look if the highest value is high enough. 
This will take O (n). 
Questions for myself:
Will the second approach really take O(n)? What about memory? Can I use hash table?
Test cases:
Code:

Exc 3
Questions:




